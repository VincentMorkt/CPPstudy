theory
    file status
        файли в репозиторії git можуть мати різний статус, який вказує, як git буде взаємодіяти з файлом
            untracked --- файл не відстежується
            modified --- файл відстежується і був змінений
            staged --- файл підготовлений до коміту
            committed --- файл зафыксований (входить в минулі коміти), змін в файлі не відбулось
            both modified --- в файлі конфлікт злиття

    commit hash --- унікальний ідентифікатор коміту, який можна побачити переглядаючи інформацію про коміт
        наприклад, скориставшись командою  $ git log. 
        Може бути переданий команді як вказівник на коміт <COMMIT_ID>
    
    HEAD вказівник
        HEAD вказує на поточний активний коміт (зазвичай останній). 
        HEAD можна передавати командам як вказівник на коміт замість його хеш-номера.
        HEAD^ - минулий коміт. HEAD^^ - позаминулий коміт. HEAD~n - коміт, з порядковим номером <поточний коміт>-n

    Fast-forward merge --- злиття без конфліктів. в базовій гілці не було жодних комітів з моменту розділення. merge commit не створюється
        Історія комітів виглядатиме, ніби всі зміни зливаємої гілки відбувалися в базовій гілці.



tasks
    • install --- https://git-scm.com/book/ru/v2/Введение-Установка-Git
    
    • створення нового git репозіторія --- $ git init --- в необхідній папці (<disk_letter>:\ --- зміна робочого диску, cd C:\...\<catalog name> --- для зміни каталогу)
    
    • створення коміту --- $ git add --- з необхідними опціями для обрання файлів, що увійдуть в коміт,
                       --- $ git commit -m "comment" --- створення коміту з коментарем, вказаним в лапках. коментар пишеться в теперішньому часі.
    
    • відкат змін --- $ git reset <option> <COMMIT_ID> --- $ git reset --soft HEAD
        !!! не можна робити reset в публічних репозиторіях не на останній публічний коміт. Це може повпливати на роботу інших людей і цілісність даних. 
        відкат змін до останнього коміту --- $ git reset $ git checkout -- .
    
    • створення віддаленого репозиторію --- 
        1. створити репозиторій на гітхабі (плюсик вгорі праворуч)
        2. скопіювати URL цього репозиторію
        3. $ git remote add <NAME_REPOSITORY> <URL> --- ввести данні для входу на гітхаб
        4. $ git push <NAME_REPOSITORY> <BRANCH_NAME> 
    
    • налаштування SSH для GitHub
        1. перевірка наявниз ключів https://docs.github.com/ru/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys
        2. створення нового SSH ключа https://docs.github.com/ru/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent
        3. додавання SSH ключа в аккаунт GitHub https://docs.github.com/ru/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account
    
    • завантаження віддаленого репозиторію
        1. скопіювати URL віддаленого репозиторію
        2. $ git clone <URL>

    • вирішення merge конфлікту
        1. Вручну відредагувати файл --- гіт залишить помітку в файлі в стилі
            <<<<<<< HEAD
            <you version>
            =======
            <another version>
            >>>>>>> <BRANCH_NAME>
        --- необхідно видалити все крім данних, що мають залишитись (мітки теж видалити)
        2. додати файл до staged і виконати commit (без коментаря)
        3. відкриється текстовий редактор vim, в якому буде інформація про конфлік злиття та обране його вирішення
            для виходу з vim треба ввести :wq
    
    • вирішення віддаленого merge конфлікту при спробі $ git push
        1. $ git pull
        2. вирішення локального merge конфлікту
        3. & git push
        


commands
    $ git --- the synopsis of the git command and a list of the most commonly used Git commands are printed on the standard output
    $ git help --- без вказання додаткових опцій те ж що й $ git
              -//- <command> --- відкрити html файл з детальною документацією по команді <command>  
    
    $ git <command> --help --- те ж саме
               -//- -h --- коротка інструкція до команди <command> (відобразиться в терміналі)
    
    $ git config --- налаштування git
            -//- --global user.name "Ім'я Прізвище" --- налаштування імені та емейла користувача 
            -//- --global user.email "@my_email@" --- є обов'язковими для роботи з git
    
    $ git init --- створення репозіторію git у відкритій в терміналі папці
    $ git add <options> --- переведення файлів в статус відстеження
         -//- . --- додати всі файли в поточній папці і підпапках
         -//- *.txt --- додати всі файли з поточної папки з розширенням txt
         -//- <dirName>/<mask> --- додати всі файли з підпапки <dirName>, які проходять фільтр заданий маскою (наприклад *.txt)
         -//- <dirName> --- додати всі файли з піпдпапки <dirName>
         -//- "<mask>" --- додати всі файли з поточної папки і підпапок, які проходять фльтр заданий маскою
    
    $ git status --- перегляд статусу репозиторія (поточні статуси файлів)
    $ git commit --- створення коміту
            -//- -m "<coment>" --- створення коміту з коментарем <coment>
            -//- -a --- виконання $ git add для всіх modified файлів після чого викликає $ git commit. 
                !!! Не впливає на untracked файли.
            -//- --amend --- переписування останнього коміту (наприклад, якщо не були додані якісь незначні зміни)
                -m "..." також перепише коментар
                буде викликаний консольний текстовий редактор vim, для завершення операції треба вийти з нього, нічого не змінюючи
                для виходу з vim треба ввести :wq
    $ git log --- перегляд історії комітів    
        q or z --- вихід з історії комітів

    $ git diff --- перегляд різниці між поточним невідстежуємим станом і останнім комітом
          -//- --staged --- перегляд різниці між поточним відстежуванним станом і останнім комітом
          -//- <COMMIT_ID> --- перегляд різниці (всієї) між поточним станом репозиторія і вказаним комітом
    
    $ git reset <option> <COMMIT_ID> --- відкат проекту до вказаного коміту (за замовчуванням $ git reset == $ git reset --mixed HEAD)
           -//- --soft --- повертає проєкт до стану коміта <COMMIT_ID>, переводить всі наступні зміни і файли в статус staged
           -//- --mixed --- (викликається за замовчуванням),   -//-   , переводить всі наступні зміни в статус modified, а новостворені файли в статус untracked
           -//- --hard ---                                     -//-   , видаляє всі наступні коміти і відповідні зміни і файли (не впливає на untracked файли)
    
    $ git checkout --- команда для переміщення між комітами, гілками і версіями фафлів
              -//- <COMMIT_ID> --- відновлення проекту до стану <COMMIT_ID>. Наступні коміти залишаться незмінними.
                    Вказіник HEAD вказує на <COMMIT_ID> і переводиться в стан DETACHED (відділенний від актуальної версії проєкту).
                    Зміни внесені в проєкт або нові коміти не будуть збережені. 
              -//- <BRANCH_NAME> --- перехід до актуального стану проєкту гілки <BRANCH_NAME>
                    Вказіник HEAD вказує на останній коміт гілки <BRANCH_NAME>
                    Зміни і нові коміти знову дозволені і будуть збережені. 
              -//- -- <COMMIT_ID> <path_to_file_1> ... <path_to_file_n> --- відновлення вказаних файлів до архівного стану, який вони мали в <COMMIT_ID>
              -//- -- <path_to_file_1> ... <path_to_file_n> --- відновлення вказаних файлів до архівного стану, який вони мали в HEAD (працює лише для modified файлів)     
              -//- -- . --- те ж саме для всіх modified файлів в репозиторії
                    !!! дві риски і пробіл після них вказують, що далі буде слідувати ім'я файлу, а не ключове слово. 
                    Дозволяє працювати з файлами, які мають назву, що збігаються з ключовими словами
                    Після відновленння до архівних версій файли переходять в статус "staged"
              -//- <BRANCH_NAME> --- переміщення до гілки <BRANCH_NAME>
    
    
    $ git clean --- видалення untracked файлів
           -//- -n --- перегляд untracked файлів доступних для видалення
           -//- -f --- видалення untracked файлів       
    
    $ git remote -v- --- перегляд списку віддалених репозиторіїв
            -//- add <NAME_REPOSITORY> <URL> --- додавання нового репориторію, який знаходиться за вказаним URL
            -//- remove <NAME_REPOSITORY> --- видалення репозиторію <NAME_REPOSITORY> з комп'ютера (не з гітхабу)
            -//- show <NAME_REPOSITORY> --- перегляд гілок проєкту, як локальних так і віддалених, а також статсів цих гілок
    
    $ git push <NAME_REPOSITORY> <BRANCH_NAME> --- відправляє всю гілку <BRANCH_NAME> на сервер в репозиторій, раніше підключений як <NAME_REPOSITORY>
          -//- --delete <NAME_REPOSITORY> <BRANCH_NAME> --- видалення гілки <BRANCH_NAME> з віддаленого репозиторію
   
    $ git pull <NAME_REPOSITORY> <BRANCH_NAME> --- "скачує" з сервера зміни в репозиторії <NAME_REPOSITORY> і додає їх в гілку
        !!! насправді механізм трохи складніший. pull створює/оновлює локальні копії віддалених гілок <NAME_REPOSITORY>/<BRANCH_NAME>
            після чого відбувається merge відповідних гілок з локальними робочими гілками. Під час цього можуть виникати конфлікти, як і при звичайному злитті
            $ git fetch виконує першу частину, а $ git merge <NAME_REPOSITORY>/<BRANCH_NAME> другу\
        

    $ git clone <URL> --- клонування відаленого репозиторія (дозволяє клонувати репозиторії, доступні лише для читання)
    & git branch --- перегляд існуючих локальних гілок з відміченою активною гілкою
            -//- <BRANCH_NAME> --- створення гілки з ім'ям <BRANCH_NAME>
            -//- -d <BRANCH_NAME> --- видалення гілки з ім'ям <BRANCH_NAME>
            -//- -D <BRANCH_NAME> --- форсоване видалення гілки
            -//- -r --- перегляд існуючих віддалених гілок
    
    $ git merge <BRANCH_NAME> --- злиття поточної гілки з гілкою <BRANCH_NAME>
    $ git fetch --- оновлення локальних копій віддалених гілок, без їх злиття з локальними робочими гілками

             



