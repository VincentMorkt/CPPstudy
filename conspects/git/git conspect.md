# **Theory**
## File status
файли в репозиторії git можуть мати різний статус, який вказує, як git буде взаємодіяти з файлом
* `untracked` --- файл не відстежується
* `modified` --- файл відстежується і був змінений
* `staged` --- файл підготовлений до коміту
* `committed` --- файл зафыксований (входить в минулі коміти), змін в файлі не відбулось
* `both modified` --- в файлі конфлікт злиття

## Commit hash 
Унікальний ідентифікатор коміту, який можна побачити переглядаючи інформацію про коміт (наприклад, скориставшись командою  $ git log.) Може бути переданий команді як вказівник на коміт <COMMIT_ID>
    
## HEAD вказівник
`HEAD` вказує на поточний активний коміт (зазвичай останній). 
`HEAD` можна передавати командам як вказівник на коміт замість його хеш-номера.
`HEAD^` - минулий коміт. `HEAD^^` - позаминулий коміт. `HEAD~n` - коміт, з порядковим номером <поточний коміт>-n

## Fast-forward merge 
Злиття без конфліктів. в базовій гілці не було жодних комітів з моменту розділення. merge commit не створюється. Історія комітів виглядатиме, ніби всі зміни додаткової гілки відбувалися в базовій гілці.

## Git readme 
* [Оформлення опису проєкту](https://docs.github.com/ru/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-readmes)
* [Форматування (відповідно до .md файлів)](https://docs.github.com/ru/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax)
---

# **Tasks**
## Install 
* [Інструкція на **git-scm.com/book**](https://git-scm.com/book/ru/v2/Введение-Установка-Git)

## Cтворення нового git репозіторія
* `$ git init` --- в необхідній папці (в консолі/Git bash --- `<disk_letter>:\` --- зміна робочого диску, `cd C:\...\<catalog name>` --- для зміни каталогу)

## створення коміту
1. `$ git add` --- з необхідними опціями для обрання файлів, що увійдуть в коміт,
2. `$ git commit -m "comment"` --- створення коміту з коментарем, вказаним в лапках. *коментар прийнято писати в теперішньому часі.*


1. або `$ git commit -a -m "..."` --- додає всі `modified` файли в `staged` після чого робить коміт.

## Відкат змін
* `$ git reset <option> <COMMIT_ID>` --- (наприклад `$ git reset --soft HEAD`). Відкат змін до останнього коміту --- `$ git reset $ git checkout -- .`
**!!! не можна робити reset в публічних репозиторіях не на останній публічний коміт. Це може повпливати на роботу інших людей і цілісність даних.**

## Створення віддаленого репозиторію
1. Створити репозиторій на гітхабі (плюсик вгорі праворуч)
2. Скопіювати URL цього репозиторію (зелена кнопка `#2c974b` `<> Code`)
3. $ git remote add <NAME_REPOSITORY> <URL> --- ввести данні для входу на гітхаб
4. $ git push <NAME_REPOSITORY> <BRANCH_NAME> 

## Налаштування SSH для GitHub
1. [Перевірка наявних ключів](https://docs.github.com/ru/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys)
2. [Створення нового SSH ключа](https://docs.github.com/ru/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)
3. [Додавання SSH ключа в аккаунт GitHub](https://docs.github.com/ru/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account)

## Завантаження віддаленого репозиторію
1. скопіювати URL віддаленого репозиторію (зелена кнопка на сторінці репозиторію `#2c974b` `<> Code`)
2. $ git clone <URL>

## Вирішення merge конфлікту
1. Вручну відредагувати файл --- гіт залишить помітку в файлі в стилі
`<<<<<<< HEAD`
`<you version>`
`=======`
`<another version>`
`>>>>>>> <BRANCH_NAME>`
Необхідно видалити все крім данних, що мають залишитись (мітки теж видалити)
2. додати файл до `staged` і виконати commit (без коментаря)
3. відкриється текстовий редактор **vim**, в якому буде інформація про конфлік злиття та обране його вирішення (для виходу з vim треба ввести **:wq** )

## Вирішення віддаленого merge конфлікту при спробі $ git push
1. `$ git pull`
2. вирішення локального merge конфлікту
3. `$ git push`

## Rebase
використовується для запобігання створення `merge commit` або для редагування історіх комітів --- переносить всю історію комітів поточної гілки у вказану гілку
1. $ git checkout <BRANCH_NAME> --- в другорядну гілку, яку треба перенести в основну
2. $ git rebase <BRANCH_NAME> --- ввести ім'я основної гілки, куди треба перенести другорядну.
3. вирішення конфлікту, якщо такий є --- стандартними способами
4. $ git rebase --continue --- повторити пункти 3-4 для наступних комітів, якщо виникає така необхідність.
5. $ git checkout <BRANCH_NAME> --- ввести ім'я основної гілки, для подальшого злиття
6. $ git merge <BRANCH_NAME> --- ввести ім'я додаткової гілки для Fast forward merge

## Rebase віддаленної гілки
Коли треба інтегрувати pull зміни без merge commit
1. `$ git fetch`
2. `$ git checkout <NAME_REPOSITORY>/BRANCH_NAME>` --- замість першого пункту минулої задачі
3. пункти 3...7 --- аналогічно 2...6 звичайного `rebase`.
---

# Commands
    
    $ git --- the synopsis of the git command and a list of the most commonly used Git commands are printed on the standard output
    
    $ git help --- без вказання додаткових опцій те ж що й $ git
              -//- <command> --- відкрити html файл з детальною документацією по команді <command>  
    
    $ git <command> --help --- те ж саме
               -//- -h --- коротка інструкція до команди <command> (відобразиться в терміналі)
    
    $ git config --- налаштування git
            -//- --global user.name "Ім'я Прізвище" --- налаштування імені та емейла користувача 
            -//- --global user.email "@my_email@" --- є обов'язковими для роботи з git
    
    $ git init --- створення репозіторію git у відкритій в терміналі папці
    
    $ git add <options> --- переведення файлів в статус відстеження
         -//- . --- додати всі файли в поточній папці і підпапках
         -//- *.txt --- додати всі файли з поточної папки з розширенням txt
         -//- <dirName>/<mask> --- додати всі файли з підпапки <dirName>, які проходять фільтр заданий маскою (наприклад *.txt)
         -//- <dirName> --- додати всі файли з піпдпапки <dirName>
         -//- "<mask>" --- додати всі файли з поточної папки і підпапок, які проходять фльтр заданий маскою
    
    $ git status --- перегляд статусу репозиторія (поточні статуси файлів)
    
    $ git commit --- створення коміту
            -//- -m "<coment>" --- створення коміту з коментарем <coment>
            -//- -a --- виконання $ git add для всіх modified файлів після чого викликає $ git commit. 
                !!! Не впливає на untracked файли.
            -//- --amend --- переписування останнього коміту (наприклад, якщо не були додані якісь незначні зміни)
                -m "..." також перепише коментар
                буде викликаний консольний текстовий редактор vim, для завершення операції треба вийти з нього, нічого не змінюючи
                для виходу з vim треба ввести :wq
    $ git log --- перегляд історії комітів    
        q or z --- вихід з історії комітів

    $ git diff --- перегляд різниці між поточним невідстежуємим станом і останнім комітом
          -//- --staged --- перегляд різниці між поточним відстежуванним станом і останнім комітом
          -//- <COMMIT_ID> --- перегляд різниці (всієї) між поточним станом репозиторія і вказаним комітом
    
    $ git reset <option> <COMMIT_ID> --- відкат проекту до вказаного коміту (за замовчуванням $ git reset == $ git reset --mixed HEAD)
           -//- --soft --- повертає проєкт до стану коміта <COMMIT_ID>, переводить всі наступні зміни і файли в статус staged
           -//- --mixed --- (викликається за замовчуванням),   -//-   , переводить всі наступні зміни в статус modified, а новостворені файли в статус untracked
           -//- --hard ---                                     -//-   , видаляє всі наступні коміти і відповідні зміни і файли (не впливає на untracked файли)
    
    $ git checkout --- команда для переміщення між комітами, гілками і версіями фафлів
              -//- <COMMIT_ID> --- відновлення проекту до стану <COMMIT_ID>. Наступні коміти залишаться незмінними.
                    Вказіник HEAD вказує на <COMMIT_ID> і переводиться в стан DETACHED (відділенний від актуальної версії проєкту).
                    Зміни внесені в проєкт або нові коміти не будуть збережені. 
              -//- <BRANCH_NAME> --- перехід до актуального стану проєкту гілки <BRANCH_NAME>
                    Вказіник HEAD вказує на останній коміт гілки <BRANCH_NAME>
                    Зміни і нові коміти знову дозволені і будуть збережені. 
              -//- -- <COMMIT_ID> <path_to_file_1> ... <path_to_file_n> --- відновлення вказаних файлів до архівного стану, який вони мали в <COMMIT_ID>
              -//- -- <path_to_file_1> ... <path_to_file_n> --- відновлення вказаних файлів до архівного стану, який вони мали в HEAD (працює лише для modified файлів)     
              -//- -- . --- те ж саме для всіх modified файлів в репозиторії
                    !!! дві риски і пробіл після них вказують, що далі буде слідувати ім'я файлу, а не ключове слово. 
                    Дозволяє працювати з файлами, які мають назву, що збігаються з ключовими словами
                    Після відновленння до архівних версій файли переходять в статус "staged"
              -//- <BRANCH_NAME> --- переміщення до гілки <BRANCH_NAME>
              -//- -b <BRANCH_NAME> --- створення гілки <BRANCH_NAME> і переміщення в неї
              -//- <NAME_REPOSITORY>/<BRANCH_NAME> --- перехід до локальної копії віддаленої гілки (яку можна отримати за допомогою $ git fetch і переглянути через $ git branch -r)
       
    $ git clean --- видалення untracked файлів
           -//- -n --- перегляд untracked файлів доступних для видалення
           -//- -f --- видалення untracked файлів       
    
    $ git remote -v- --- перегляд списку віддалених репозиторіїв
            -//- add <NAME_REPOSITORY> <URL> --- додавання нового репориторію, який знаходиться за вказаним URL
            -//- remove <NAME_REPOSITORY> --- видалення репозиторію <NAME_REPOSITORY> з комп'ютера (не з гітхабу)
            -//- show <NAME_REPOSITORY> --- перегляд гілок проєкту, як локальних так і віддалених, а також статсів цих гілок
    
    $ git push <NAME_REPOSITORY> <BRANCH_NAME> --- відправляє всю гілку <BRANCH_NAME> на сервер в репозиторій, раніше підключений як <NAME_REPOSITORY>
          -//- --delete <NAME_REPOSITORY> <BRANCH_NAME> --- видалення гілки <BRANCH_NAME> з віддаленого репозиторію
   
    $ git pull <NAME_REPOSITORY> <BRANCH_NAME> --- "скачує" з сервера зміни в репозиторії <NAME_REPOSITORY> і додає їх в гілку
        !!! насправді механізм трохи складніший. pull створює/оновлює локальні копії віддалених гілок <NAME_REPOSITORY>/<BRANCH_NAME>
            після чого відбувається merge відповідних гілок з локальними робочими гілками. Під час цього можуть виникати конфлікти, як і при звичайному злитті
            $ git fetch виконує першу частину, а $ git merge <NAME_REPOSITORY>/<BRANCH_NAME> другу\
        
    $ git clone <URL> --- клонування відаленого репозиторія (дозволяє клонувати репозиторії, доступні лише для читання)
    
    & git branch --- перегляд існуючих локальних гілок з відміченою активною гілкою
            -//- <BRANCH_NAME> --- створення гілки з ім'ям <BRANCH_NAME>
            -//- -d <BRANCH_NAME> --- видалення гілки з ім'ям <BRANCH_NAME>
            -//- -D <BRANCH_NAME> --- форсоване видалення гілки
            -//- -r --- перегляд існуючих копій віддалених гілок
    
    $ git merge <BRANCH_NAME> --- злиття поточної гілки з гілкою <BRANCH_NAME>
    
    $ git fetch --- оновлення локальних копій віддалених гілок, без їх злиття з локальними робочими гілками

    $ git rebase --- альтернатива $ git merge, яка уникає створення merge commit. переносить всю історію комітів поточної гілки у вказану гілку.        
            -//- <BRANCH_NAME> перебазує всю поточну гілку в кінець гілки <BRANCH_NAME>
                це відбувається через додавання нових комітів <BRANCH_NAME> на початок поточної гілки
                !!! можуть виникнути конфлікти злиття, вірішуються аналогічно merge конфліктам
            -//- --continue --- продовження операції після вирішення конфлікту
            -//- --abort --- переривання операції  
    
    $ git rebase -i <COMMIT_ID> --- інтерактивний ребейз, дозволяє маніпулювати комітами в рамках однієї гілки
        починаючи з наступного коміта після <COMMIT_ID> і закінчуючи HEAD
        !!! відкриває вікно редактору і інструкцій
        в редакторі перші строки відповідають комітам, і в них можна додавати відповідні інструкції або видаляти
        !!! для редагування треба натиснути i в англійській розкладці. після закінчення редагування треба натиснути esc та :wq для вихода і застосування змін.
        після чого відбудеться rebase для цих комітів відповідно вказаних інструкцій в поточну гілку. 
        під час цього можуть виникнути конфлікти, які вирішуються стандартним способом
    
    $ git cherry-pick <COMMIT_ID> --- копія вказаного коміту в поточну гілку
                 -//- --edit --- дозволяє поміняти повідомлення коміту
                 -//- --no-commit --- не копіює коміт, але переносить його як зміни в staged
                 -//- -x в повідомлені буде вказаний хеш оригынального коміту
                 -//- --signoff --- вказує в коментарі ім'я користувача, здійснившего cherry-pick
                 


