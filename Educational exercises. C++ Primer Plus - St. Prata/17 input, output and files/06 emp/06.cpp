// 6. Рассмотрите определение класса, предложенное в упражнении 5 главы 14. Если вы еще не делали это упражнение, выполните его сейчас. Затем сделайте следующее.
// Напишите программу, которая использует стандартный ввод-вывод С++ и файловый ввод-вывод в сочетании с данными типов employee, manager, fink и highfink, как определено в упражнении 5 из главы 14.
// Программа должна быть аналогична главным строкам листинга 17.17 в том, что должна позволять вносить новые данные в файл.
// При первом запуске программа должна запросить данные у пользователя, показать все введенные записи и сохранить информацию в файл.
// При последующих запусках она должна сначала прочитать и отобразить данные файла, дать возможность пользователю добавить новые данные и отобразить все данные снова.
// Единственное отличие должно состоять в том, что данные должны быть представлены в виде массива указателей на тип employee.
// Таким образом, указатель может указывать на объект employee либо на объект любого из трех производных от него типов.
// Сохраняйте массив маленьким, чтобы облегчить его проверку программой; например, его размер можно ограничить 10 элементами:
const int MAX = 10; // не более 10 объектов
employee *pe[MAX];
// Для клавиатурного ввода программа должна использовать меню, чтобы предоставить пользователю выбор типа создаваемого объекта.
// С меню должен быть связан оператор switch, позволяющий использовать операцию new для создания объекта требуемого типа и присваивать адрес этого объекта
// указателю в массиве ре. Затем этот объект может вызвать виртуальную функцию setall() для запроса соответствующих данных от пользователя:
pc[i]->setall(); // вызывает функцию, соответствующую типу объекта
// Чтобы обеспечить сохранение данных в файле, необходимо объявить виртуальную функцию writeall():
for (i = 0; i < index; i++)
    pc[i]->writeall(fout); // объект fout типа ofstream подключен к выходному файлу
// Сложность представляет восстановление данных из файла. Проблема состоит в том, как программа узнает, какого типа объект будет восстановлен следующим:
// employee, manager, fink либо highfink? Один из возможных подходов к решению этой проблемы заключается в следующем:
// при записи данных объекта в файл предварить его целым числом, идентифицирующим тип следующего объекта.
// Затем при вводе из файла программа может читать это целое число и применять switch для создания объекта соответствующего типа для приема данных:

enum classkind
{
    Employee,
    Manager,
    Fink,
    Highfink
}; // в заголовке класса
// ...
int classtype;
while ((fin >> classtype).get(ch))
{ // символ новой строки отделяет целое число от данных
    switch (classtype)
    {
    case Employee:
        pc[i] = new employee;
        break;

        // Затем можно использовать указатель, чтобы вызвать виртуальную функцию getall() для считывания информации:
        pc[i++]->getall();
