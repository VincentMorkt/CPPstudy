/*
// 1. Посмотрите на следующие два фрагмента кода для подсчета пробелов и переводов строк:
// Версия 1
while (cin.get(ch)) // завершение по eof
{
    if (ch == ' ')
        spaces++;
    if (ch == '\n')
        newlines++;
}
// Версия 2
while (cin.get(ch)) // завершение по eof
{
    if (ch == ' ')
        space s++;
    else if (ch = '\n')
        newline s++;
}
// Какие преимущества (если они есть) у второй формы перед первой?
// вторая форма работает немного быстрее, поскольку для прошедших первую проверку символов вторая проверка проводиться не будет.

// 2. Какой эффект даст замена в листинге 6.2 выражения ++ch на ch + 1?
// ch + 1 будет преобразован в int (поскольку 1 это int), в то время как ++ch останется char

// 3. Внимательно изучите следующую программу:
#include <iostream>
using namespace std;
int main()
{
    char ch;
    int ct1, ct2;
    ct1 = ct2 = 0;
    while ((ch = cin.get()) != '$')
    {
        cout << ch;
        ct1++;
        if (ch = '$')
            ct2++;
        cout << ch;
    }
    cout << "ct1=" << ct1 << ", ct2=" << ct2 << "\n";
    cin.get();
    cin.get();
    return 0;
}

// Предположим, что вы вводите следующие строки, нажимая клавишу <Enter> в конце каждой строки:
// Hi!
// Send $10 or $20 now!
// Каким будет вывод? (Вспомните, что ввод буферизуется.)
// Hi!
// H$i$!$
// $Send $10 or $20 now!
// $S$e$n$d$ $ct1=9, ct2=9

// 4. Постройте логические выражения для представления перечисленных ниже условий.
// а. weight больше или равно 115, но меньше 125. (weight >= 115 && weight < 125)

// б. ch равно q или Q. (ch == 'q' || ch == 'Q') or #include <cctype> (toupper(ch) == 'Q')

// в. х - четное, но не равно 26. (x % 2 == 0 && x != 26)
// г. х - четное, но не кратно 26. (x % 2 == 0 && x % 26 != 0)

// д. donation находится в диапазоне 1000-2000 или guest равно 1. ((donation >= 1000 && donation < 2000) || guest == 1)

// е. ch - буква в нижнем или верхнем регистре. (Предполагается, что буквы нижнего регистра кодируются последовательно и буквы верхнего регистра также
// кодируются последовательно, но между буквами нижнего и верхнего регистров имеется промежуток.)
// ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z'))

// 5. В английском языке предложение "I will not not speak" означает то же, что и
// "I will speak". Является ли выражение !!x в языке C++ тем же самым, что и x?
// Нет, не является (за исключением, когда х имеет тип bool). По факту это выражение преобразует х в bool.

// 6. Постройте условное выражение, которое эквивалентно абсолютному значению
// переменной. То есть если значение х положительное, то значением выражения
// будет просто х, но если значение х отрицательное, то значением выражения
// должно быть -х, которое является положительным.
// (x < 0) ? -x : x;

// 7. Перепишите следующий фрагмент с применением switch:
if (ch == 'A')
    a_grade++;
else if (ch == 'B')
    b_grade++;
else if (ch == 'C')
    c_grade++;
else if (ch = = 'D')
    d_grade++;
else
    f_grade++;

switch (ch)
{
case 'A':
    a_grade++;
    break;
case 'B':
    b_grade++;
    break;
case 'C':
    c_grade++;
    break;
case 'D':
    d_grade++;
    break;
default:
    f_grade++;
    break;
}

// 8. Каково преимущество в листинге 6.10 использования символьных меток, таких
// как а и с, вместо цифр для выбора в меню и в операторе switch?
// (Подсказка: подумайте о том, что произойдет, если пользователь введет q в любом регистре,
// и что случится, когда он введет в любом регистре 5.)
// символьные метки позволяют без ошибки ввода принимать числовой ввод, но не наоборот.

// 9. Посмотрите на следующий фрагмент кода:
int line = 0;
char ch;
while (cin.get(ch))
{
    if (ch == 'Q')
        break;
    if (ch != '\n')
        continue;
    line++;
}
// Перепишите этот код так, чтобы в нем не использовались операторы break и continue.
while (cin.get(ch) && ch != 'Q')
    if (ch == '\n')
        line++;
*/