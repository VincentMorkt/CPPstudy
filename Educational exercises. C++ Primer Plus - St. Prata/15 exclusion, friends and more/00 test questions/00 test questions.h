// 1. Что неверно в следующих попытках создания дружественных конструкций:
// a.
// class snap
// {
//     friend clasp; // нужно указать, что clasp это класс: friend class clasp;
//     ...
// };
// class clasp
// {
//     ...
// };

// // b.
// class cuff
// {
// public:
//     void snip(muff &) { ... } 
//     // встроенное определение метода требует упреждающее объявление класса muff
// };
// class muff
// {
//     friend void cuff::snip(muff &); 
//     ...
// };

// // c.
// class muff
// {
//     friend void cuff::cnip(muff &); // необходимо поменять объявления классов местами
//     // чтобы к моменту объявления функции дружественной компилятор уже знал о её существовании
//     ...
// };
// class cuff
// {
// public:
//     void snip(muff &){...} // потребуется упреждающее объявление muff, поскольку порядок объявлений будет другим
//     ...
// };

// 2. Вы уже видели, как создаются взаимно дружественные классы. Возможно ли
// создать более ограниченную форму отношения дружественности, при котором
// только некоторые члены класса В являются друзьями для класса А и некоторые
// члены класса А - друзьями для в? Обоснуйте свой ответ.

// Нет, мы можем сделать дружественными только методы одного класса для другого. 
// Класу, объявленному первым, будет недоступна информация о методах второго класса,
// соответственно объявить их дружественными невозможно.

// 3. Какие проблемы могут возникнуть в следующем объявлении вложенного класса?
// class Ribs
// {
// private:
//     class Sauce
//     {
//         int soy;
//         int sugar;

//     public:
//         Sauce(int s1, int s2) : soy(s1), sugar(s2) {}
//     };
//     ...
// }
// вложеный класс имеет закрытые данные-члены, 
// но доступ к ним ограничен только созданием через конструктор. Из невозможно даже прочитать.

// 4. В чем состоит различие между throw и return?
// reurn завершает выполнение функции и возвращает программу на одну ступень выше,
// в вызвавшую фунецию. Программа переходит к выполнению следующего оператора.
// throw завершает выполнение функции и всей цепочки вложеных функций до блока try, внутри которого был вызван throw. 
// после этого программа переходит не к следующему оператору, а к блоку catch, 
// перехватывающему тип исключений, сгененрированный throw (или завершается, если такого нет)

// 5. Предположим, что имеется иерархия классов исключений, порожденная от
// базового класса исключений. В каком порядке следует расположить блоки саtch?
// В обратном, от производного к базовому. Первый должен перехватывать самый молодой класс, второй его родителя, и т.д.
// Если расположить классы в прямом порядке, то все исключения будут перехвачены первым блоком, поскольку
// указатель на базовый класс принимает адреса производных классов. 



// 6. Рассмотрим классы Grand, Superb и Magnificent, определенные в настоящей главе.
// Пусть pg - указатель типа Grand *, которому присвоен адрес объекта одного
// из этих трех классов, а ps - указатель типа Superb *.
// В чем разница в поведении двух следующих примеров кода?
// if (ps = dynamic_cast<Superb *>(pg)) //позволяет работать в том числе с производными от Superb классами
//     ps->say(); // пример 1
// if (typeid(*pg) == typeid(Superb)) // работает Superb так же, но требует отдельного if для каждого производного класса.
//     ((Superb *)pg)->say(); // пример 2 

// 7. Чем отличается операция static_cast от операции dynamic_cast?
// dynamic_cast преобразует указатель базового типа в указатель производного типа, когда это вомзожно сделать безопасно
// static_cast может сделать это же, но также и преобразование в обратную сторону, из производного класса в базовый
// в целом операция static_cast - альтернатива обычным явным преобразованиям