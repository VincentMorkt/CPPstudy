;
// 1. Пусть имеется следующее объявление класса :
#include <cstring>

class RQ1
{
private:
    char *st; // указатель на строку в стиле С
public:
    RQ1()
    {
        st = new char[1];
        strcpy(st, "");
    }
    RQ1(const char *s)
    {
        st = new char[strlen(s) + 1];
        strcpy(st, s);
    }
    RQ1(const RQ1 &rq)
    {
        st = new char[strlen(rq.st) + 1];
        strcpy(st, rq.st);
    }
    ~RQ1() { delete[] st; }
    RQ1 &operator=(const RQ1 &rq);
    // Другие операторы
};
// Преобразуйте его в объявление, использующее объект s t r ing. Какие методы
// больше не нуждаются в явных определениях?

// 2. Назовите хотя бы два преимущества объектов string по сравнению со строками
// в стиле С с точки зрения простоты применения.

// 3. Напишите функцию, которая принимает ссылку на объект string в качестве
// аргумента и затем преобразует объект string в прописные буквы.

// 4. Какие из следующих операторов не являются примерами корректного использования
// (концептуально или синтаксически) объекта auto_ptr?
// (Предполагается, что все необходимые заголовочные файлы включены.)
auto_ptr<int> pia(new int[20]); // необходимо использовать new [], указатель на массив может создавать только unique _ptr, поскольку имеет версию с delete []
auto_ptr<string>(new string);   // неименованный указатель, не имеет смысла, поскольку объекты auto_ptr нельзя присваивать
int rigue = 7;
auto_ptr<int> pr(&rigue); // нельзя создавать динамический указатель на не-динамический объект (это приведёт к попытке применить delete к стеку памяти, что неверно)
auto_ptr dbl(new double); // неправильный синтаксис, необходимо указать <тип> для шаблонного класса, указатель на который создаётся

// 5. Если бы можно было создать механический эквивалент стека, который хранит
// клюшки для гольфа вместо номеров, почему он был бы (концептуально) плохой
// сумкой для гольфа?

// 6. Почему контейнер set - неудачный выбор для хранения записей о полученных
// очках в гольфе в формате "от лунки к лунке"?

// 7. Если указатель - это итератор, почему разработчики STL просто нс используют его вместо итераторов?

// 8. Почему разработчики STL не определили базовый класс итератора, 
// используя наследование для порождения классов для других типов итераторов, 
// и не выразили алгоритмы в терминах этих классов итераторов?

// 9. Приведите, как минимум, три примера, показывающих преимущества объекта
// vector по сравнению с обычным массивом.

// 10. Если в коде из листинга 16.9 использовать list вместо vector, то какие части
// программы станут некорректными? Легко ли они могут быть исправлены? Если да, то как?