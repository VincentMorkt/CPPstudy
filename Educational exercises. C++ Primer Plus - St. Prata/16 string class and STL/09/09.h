// 9. По сравнению с массивом связный список отличается более простым добавлением и 
// удалением элементов, но медленной сортировкой. Поэтому возникает вопрос: 
// возможно, было бы быстрее скопировать список в массив, отсортировать
// массив и скопировать отсортированный результат обратно в список, чем просто
// использовать алгоритм списка для сортировки. (Но это может быть связано с
// наличием большего объема памяти.) Проверьте гипотезу о более быстром выполнении задачи, 
// применив следующий подход.
// а. Создайте большой объект viO типа vector<int>, используя rand() для задания начальных значений.
// б. Создайте второй объект vi типа vector<int> и объект li типа list<int>
// того же размера, что и исходный, и инициализируйте их значениями исходного вектора.
// в. Замерьте время, требуемое программе для сортировки vi с помощью алгоритма sort() из STL, 
// а затем время, необходимое для сортировки li посредством метода list sort().
// г. Переустановите li неотсортированным содержимым viО. 
// Замерьте время выполнения смешанной операции копирования li в vi, 
// сортировки vi и копирования результата обратно в li.

// Для измерения времени выполнения этих операций можно использовать
// clock() из библиотеки ctime. Как показано в листинге 5.14, 
// для запуска первого таймера можно применять следующий оператор:
clock_t start = clock();
// Для получения прошедшего времени в конце операции используйте следующий
// оператор:
clock_t end = clock();
cout << (douиle)(end-start)/CLOCKS_PER SEC;

// Вне всяких сомнений, этот тест показателен, поскольку результаты будут зависеть 
// от ряда факторов, в том числе объема доступной памяти, применения
// многопроцессорной обработки и размеров массива или списка. 
// (С увеличением количества сортируемых элементов можно ожидать большего увеличения
// эффективности массива по сравнению со списком.) Кроме того, при наличии
// выбора между стандартной сборкой и окончательной сборкой, следует выбирать 
// окончательную сборку. В современных высокоскоростных компьютерах
// для получения репрезентативных результатов необходимо использовать массив
// максимально возможного размера. Например, можно иметь 100 000, 1 000 000 и
// 10 000 000 элементов. 