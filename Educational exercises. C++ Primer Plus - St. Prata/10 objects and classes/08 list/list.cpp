// Простой список можно описать следующим образом :
// • простой список может содержать ноль или более элементов определенного типа;
// • можно создавать пустой список;
// • можно добавлять элемент в список;
// • можно определять, пуст ли список;
// • можно определять, полон ли списqк.
// • можно посетить каждый элемент списка и выполнит над ним определенное действие.

// Как видите, список действительно прост; так, например, он не позволяет осуществлять вставку или удаление элементов.
// Спроектируйте класс List для представления этого абстрактного типа.
// Вы должны подготовить заголовочный файл list.h с объявлением класса и файл list.cpp с реализацией его методов.
// Вы должны также написать короткую программу, которая будет использовать полученный класс.
// Главная причина того, что спецификация списка проста, связана с попыткой упростить это упражнение.
// Вы можете реализовать список в виде массива или же в виде связного списка, если знакомы с этим типом данных.
// Однако открытый интерфейс не должен зависеть от вашего выбора. То есть открытый интерфейс не должен иметь индексов массива, указателей на узлы и т.п.
// Он должен быть выражен в виде общих концепций создания списка, добавления элемента в список и т.д.
// Обычный способ управления посещением каждого элемента в списке и выполнения над ним каких-то действий состоит в применении функции,
// которая принимает указатель на другую функцию в качестве аргумента: void visit(void (*pf)(Item &));
// Здесь pf указывает на функцию (не функцию-член), которая принимает ссылку на аргумент типа Item, где Item - это тип элементов списка.
// visit() применяет эту функцию к каждому элементу списка. В качестве общего руководства можете воспользоваться классом Stack.

//  list.cpp -- реализация методов класса

#include <iostream>
#include "list.h"

List::List() // создание пустого списка
{
   top = 0; // установка индекса елмента в 0
}

bool List::push(const Item &item) // добавление елемента списка
{
   if (top < MAX) // если индекс елемента стека не максимальный (стек не полон)
   {
      items[top++] = item; // добавить в ячейку хранилища с текущим индексом элемент, переданный в аргументе
      return true;         // после чего увеличить индекс елемента и вернуть true
   }
   else // иначе вернуть false
      return false;
}

bool List::isempty() // проверка, пуст ли список
{
   return top == 0; // если индекс == 0, вернёт true
}

bool List::isfull() // проверка, полон ли список
{
   return top == MAX; // если индекс == MAX, вернёт true
}

void List::visit(void (*pf)(Item &)) // выполнение функции, переданной в аргументе, над элементами стека
{
   for (int i = 0; i < top; i++) // цикл, позволяющий применить функцию ко всем элементам стека
      pf(items[i]);              // вызов функции, переданной в аргументе
}
