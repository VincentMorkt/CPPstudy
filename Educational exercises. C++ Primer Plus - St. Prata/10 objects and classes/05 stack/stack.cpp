// 5. Пусть имеется следующее объявление структуры:
// struct customer
// {
//     char fullname[35];
//     double payment;
// };
// Напишите программу, которая будет добавлять структуры заказчиков в стек и удалять их из стека, представленного объявлением класса Stack.
// Всякий раз, когда заказчик удаляется из стека, его зарплата должна добавляться к промежуточной сумме и по этой сумме выдаваться отчет.
// На заметку: вы должны иметь возможность пользоваться классом Stack без изменений;
// просто поменяйте объявление typedef, чтобы Item был типом customer вместо unsigned long.

// stack.cpp -- реализация методов

#include "stack.h"

Stack::Stack() // создание пустого стека
{
    top = 0;
}

bool Stack::isempty() const // проверяет, пуст ли стек
{
    return top == 0; // возвращает true если выражение истинно
}

bool Stack::isfull() const // проверяет, полон ли стек
{
    return top == MAX;
}

bool Stack::push(const Item &item) // добавляет елемент в стек, или возвращает false если тот полон
{
    if (top < MAX)
    {
        items[top++] = item; // сначала присваивает items[top] переданное в аргументе значение, затем совершает инкремент top
        return true;
    }
    else
        return false;
}

bool Stack::pop(Item &item) // выталкивает элемент с вершины стека, или возвращает false если тот пуст
{
    if (top > 0)
    {
        item = items[--top]; // присваивает item значение елемента стека items[--top] (может это делать, поскольку передан адресс)
        return true;
    }
    else
        return false;
}