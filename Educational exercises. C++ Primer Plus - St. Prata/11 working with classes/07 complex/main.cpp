// 7. Комплексное число состоит из двух частей - вещественной и мнимой. Один из способов записи такого числа выглядит как (3.0, 4.0) . Здесь 3.0 - вещественная часть, а 4.0 - мнимая.
// Предположим, что а = (А, Bi) и с = (С, Di). Ниже представлены некоторые операции с комплексными числами:

// • сложение: а + с = (А + С, (В + D)i)
// • вычитание: а - с = (А - С, (В - D)i)
// • умножение: а * с = (А * С - B * D, (A * D + B * C)i)
// • умножение (х - вещественное число): х * с = (х * С, x * Di)
// • сопряжение: -а = (А, - Bi)

// Определите класс complex так, чтобы следующая программа могла использовать его с корректными результатами:

// Не забывайте, что вы должны перегрузить операции << и >>.
// В стандарте С++ уже присутствует поддержка комплексных чисел - и намного более развитая, чем в этом примере - в заголовочном файле complex,
// поэтому во избежание конфликтов назовите свой файл complexO.h. Используйте const там, где это оправдано.

#include <iostream>
using namespace std;
#include "complex07.h" // во избежание конфликта с complex.h

int main()
{
    complex a(3.0, 4.0); // инициализация значением (3, 4i)
    complex c;
    cout << "Enter a complex number (q to quit):\n"; // ввод комплексного числа (q для завершения)
    while (cin >> c)
    {
        cout << "c is " << c << '\n';                  // значение с
        cout << "complex conjugate is " << -c << '\n'; // значение сопряженного числа
        cout << "a is " << a << '\n';                  // значение a
        cout << "a + c is " << a + c << '\n';          // значение а + с
        cout << "a - c is " << a - c << '\n';          // значение а - с
        cout << "a * c is " << a * c << '\n';          // значение а * с
        cout << "2 * c is " << 2 * c << '\n';          // значение 2 * с
        cout << "Enter a complex number (q to quit):\n";
    }
    cout << "Done!\n";
    cin.clear();              // без этого программа будет закрываться прежде чем мы увидим done, поскольку cin.get() c флагом failbit не будет работать.
    while (cin.get() != '\n') // после ввода q или другого неподходящего символа в потоке ввода остаётся как минимум 2 символа - q и \n.
        continue;             // Соответственно, нам нужно как минимум три cin.get() для очистки потока ввода и ожидания перед закрытием. лучше реализовать через цикл на случай некоректного ввода
    cin.get();                // ожидание перед закрытием
    return 0;
}
