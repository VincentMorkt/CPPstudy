// 6. Перепишите класс Stonewt (листинги 11.16 и 11.17) так, чтобы перегружались все шесть операций сравнения.
// Операции должны сравнивать члены pounds и возвращать значение типа bool.
// Напишите программу, которая объявляет массив из шести объектов Stonewt с инициализацией в объявлении первых трех из них.
// Затем программа должна в цикле читать значения, используемые для установки остальных трех элементов массива.
// После этого программа должна вывести самый маленький элемент, самый большой, а также количество элементов, которые больше или равны 11 стоунам.
// (Простейший подход предполагает создание объекта Stonewt, инициализированного 11 стоунами, и сравнение с ним других объектов.)

// main.cpp -- программа демонстратор класса Stonewt

#include <iostream>
#include "stonewt06.h"

int main()
{
    using namespace std;

    const int SIZE = 6;           // размер массива
    Stonewt StoneApp[SIZE] = {10, // объявление массива объектов и инициализация первых трёх из них
                              20,
                              30};

    for (int i = 3; i < SIZE; i++) // цикл ввода 3 последних значений в массив
    {
        double temp;
        cout << "Enter pounds for " << i + 1 << " objects: ";
        cin >> temp;
        StoneApp[i] = temp; // будет применено автоматическое преобразование типа с использованием конутруктора, имеющего 1 аргумент double
    }

    Stonewt *max = &StoneApp[0];                   // указатели на меньшее и большее значения
    Stonewt *min = &StoneApp[0];                   // инициализированны адрессом нулевого элемента для последующего сравнения с остальными
    Stonewt st11(11, 0.0);                         // объект для сравнения
    int numOfst11 = (StoneApp[0] >= st11) ? 1 : 0; // если нулевой элемент >= 11 стоунам
    // такая странная форма нужна для корректного подсчёта в цикле (поскольку цикл сравнения начинается на с 1 элемента)

    for (int i = 1; i < SIZE; i++) // цикл сравнения
    {
        max = (*max > StoneApp[i]) ? max : &StoneApp[i]; // указатель равен (если значение по указателю больше текущего элемента массива) ? самому себе : адрессу текущего элемента массива
        min = (*min < StoneApp[i]) ? min : &StoneApp[i];
        if (StoneApp[i] >= st11) // подсчёт количества элементов >= 11 стоунов
            numOfst11++;
    }

    cout << "max element is: "; // отображение результатов
    max->show_lbs();
    cout << "min element is: ";
    min->show_lbs();
    cout << "number of elements >= 11 stone: " << numOfst11 << endl;
    cin.get();
    cin.get();
}
