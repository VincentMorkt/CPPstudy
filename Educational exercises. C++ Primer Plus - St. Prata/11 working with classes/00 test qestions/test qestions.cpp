// 1. Воспользуйтесь функцией-членом для перегрузки операции умножения в классе Stonewt; определите операцию умножения членов данных на значение типа double.
// Имейте в виду, что нужно будет позаботиться о представлении "стоун-фунт". То есть удвоение 10 стоунов и 8 фунтов должно давать 21 стоун и 2 фунта.

// 4. Воспользуйтесь дружественной функцией для перегрузки операции умножения в классе Stonewt; определите операцию умножения значения double на значение Stone.

class stonewt
{
    enum
    {
        Lbs_per_stn = 14 // фунтов на стоун
    };
    int stone;       // полных стоунов
    double pds_left; // дробное число фунтов
    double pounds;   // общий вес в фунтах
public:
    stonewt(double lbs); // конструктор для значения в фунтах
    // ...
    stonewt operator*(double n);                    // #1 функция - член, объявление
    friend stonewt operator*(double n, stonewt &a); // #4 дружественная функция, объявление
};
stonewt::stonewt(double lbs) // конструктор для значения в фунтах
{
    stone = int(lbs) / Lbs_per_stn;                     // целочисленное деление
    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs); // целочисленный остаток от деления + значение - целая часть значения
    pounds = lbs;
}
// ...
stonewt stonewt::operator*(double n) // #1 функция - член, определение
{
    stonewt mult(stone * Lbs_per_stn * n + pds_left * n); // использование конструктора для значения в фунтах.
    return mult;                                          // возврат результата выражения
}
stonewt operator*(double n, stonewt &a) // #4 дружественная функция, определение
{
    return a * n; // использование функции-члена
}

// 2. В чем отличия между дружественной функцией и функцией-членом?
// Функция член не требует операции членства для вызова. Это удобно, когда первый оператор - не объект класса.
// с точки зрения синтаксиса дружественная функция объявляется внутри класса (в разделе public:), как и функция - член.
// Перед такой функцией или в объявлении, или в определении указывается квалификатор friend, при этом в определении не используется операция разрешения контекста className::function();

// 3. Должна ли функция, не являющаяся членом, быть дружественной для того, чтобы иметь доступ к членам класса?
// Да, если речь о членах класса из раздела private:

// 5. Какие операции не могут быть перегружены?
// sizeof
// .  - операция членства
// .* - операция указателя на член
// :: - операция разрешения контекста
// :? - условная операция
// typeid - RTTI
// const_cast - операции приведения типа
// dynamic_cast
// reinterpret_cast
// static_cast

// 6. Какие ограничения накладываются на перегрузку следующих операций: =, () ,[] и ->?
// эти операции могут быть перегружены только функциями-членами классов.

// 7. Определите функцию преобразования для класса Vector, которая будет приводить объект Vector к значению типа double, которое представляет длину вектора.

class Vector // объявление класса
{
public:
    enum Mode
    {
        RECT,
        POL
    }; // прямоугольные, полярные координаты (константы для метки)

private:
    double x;   // горизонтальное значение
    double y;   // вертикальное значение
    double mag; // длина вектора
    double ang; // направление вектора в градусах
    Mode mode;  // RECT or POL

public:
    /* explicit */ operator double() // #7 функция преобразования типа Vector в тим double. explicit запрещает неявные преобразования
    {
        return mag; // возврат члена mag, который уже является числом типа double и представляет длину вектора
    }
};
