/*
// 1. Назовите три шага по созданию функции.
// 1. Прототипирование
// 2. Объявление
// 3. Вызов

// 2. Постройте прототипы, которые соответствовали бы следующим описаниям.
// а. igor () не принимает аргументов и не возвращает значения.
void igor();
// б. tofu () принимает аргумент int и возвращает float.
float tofu(int);
// в. mpg ( ) принимает два аргумента типа douЬle и возвращает douЬle.
double mpg(double a, double b);
// г. summation () принимает имя массива long и его размер и возвращает значение long.
long summation(long arr[], int num);
//д. doctor () принимает строковый аргумент (строка не должна изменяться) и возвращает douЬle.
double doctor(const char *line);
//е. ofcourse () принимает структуру boss в качестве аргумента и не возвращает ничего.
struct boss;
void ofcourse(boss);
//ж. plot () принимает указатель на структуру map в качестве аргумента и возвращает строку.
struct map;
char *pilot(map);

// 3. Напишите функцию, принимающую три аргумента: имя массива int , его размер и значение int. Функция должна присвоить каждому элементу массива это значение int.
void myFunction(int arr[], int size, int value);
void myFunction(int arr[], int size, int value)
{
    while (size--)
        ;
    arr[size] = value;
    return;
}

// 4. Напишите функцию , принимающую три аргумента: указатель на первый элемент диапазона в массиве, указатель на элемент, следующий за концом этого
//диапазона, и значение int. Функция должна присвоить каждому элементу диапазона массива это значение int.
void myFunction(int *begin, int *end, int value);
void myFunction(int *begin, int *end, int value)
{
    while (begin == end)
    {
        *begin = value;
        begin++;
    }
}

// 5. Напишите функцию , принимающую имя массива double и его размер в качестве аргументов и возвращающую наибольшее значение, которое содержится
//в этом массиве. Обратите внимание, что функция не должна модифицировать содержимое массива.
double MAX(const double *arr, int size);
double MAX(const double *arr, int size)
{
    int numOfMax = 0;
    for (int i = 0; i < size - 1; i++)

    {
        if (arr[i] < arr[i + 1])
            numOfMax = i + 1;
    }
    return arr[numOfMax];
}
// 6. Почему вы не используете квалификатор const для аргументов функций, относящихся к любому из базовых типов?
//  Квалификатор const при аргументе функции *указателе предназначен для недопущения изменения первоначальных данных при работе с ними через указатель.
//  При объявлении аргументов, относящихся к базовым типам, функция работает с копиями значений, поэтому нет необходимости делать их константными.

// 7. Каковы три формы строк в стиле С могут встретиться в программах С++?
char line1[20];          // символьный массив
char *line2 = {"line3"}; // указатель на char, инициализированный значением = {строковой литералл}

// 8. Напишите функцию, имеющую следующий прототип: int replace(char *str, char c1, char c2)
//Эта функция должна заменять каждое появление c1 в строке str на с2 и возвращать количество выполненных замен.
int replace(char *str, char c1, char c2)
{
    while (*str)
        if (*str == c1)
            *str = c2;
    str++;
}

// 9. Что означает выражение *"pizza"? А как насчет "taco"[2]?
/* Это некорректный синтаксис, который компилятор не поймёт. Строковой литерал преобразуется в выражениях в указатель на первый символ массива char,
инициализированного значением этого литералаа.
const char *name = {"pizza"}. теперь "pizza" эквивалентно name и обе эти формы содержат адрес 'p'. Применив операцию разименования * к name мы получим значение *name == 'p'.
Но применить операцию разименования к строковому литераллу невозможно.
Также мы не можем применить операцию индекса массива к "taco". const char *name [2] - массив указателей на char, но "taco"[2] - просто неправильный синтаксис */

// 10. С++ позволяет передавать структуры по значению, а также передавать адрес структуры. Если glitz - структурная переменная, как передать ее по значению?
// Объявить прототип функции, принимающей в качестве одного из аргументов структуру, переменной которой является glitz. При вызове функции передать имя переменной glitz как соответствующий аргумент.
// Как передать ее адрес? Каковы преимущества и недостатки обоих подходов?
// Прототип должен принимать указатель на структуру вместо структуры, при вызове функции передать &glitz. Преимущества - не создаётся копия структуры, а только копия адресса, что
// улучшает производительность в случае с большими структурами. Но функция будет работать с исходными данными, которые содержатся в переменных-членах структуры. Таким образом она либо
// будет иметь возможность их безвозвратно изменить, либо (при использовании мобификатора const) не будет способна менять эти данные.

// 11 . Функция judge() имеет тип возврата int. В качестве аргумента она принимает адрес функции. Функция, адрес которой ей передается, в свою очередь,
// принимает аргумент типа const char и возвращает int. Напишите прототип функции.
int judge(int (*myFunction3)(const char));

// 12. Предположим, что есть следующее объявление структуры:
struct applicant
{
    char name[30];
    int credit_ratings[3];
};
// а. Напишите функцию , которая принимает структуру applicant в качестве аргумента и отображает ее содержимое.
#include <iostream>
void printApplicant1(const applicant app)
{
    using namespace std;
    cout << "Name: " << app.name << endl
         << "Cradit ratings: " << app.credit_ratings << endl;
}
// б. Напишите функцию, которая принимает адрес структуры applicant в качестве аргумента и отображает содержимое структуры, на которую он указывает.
void printApplicant2(const applicant *app)

{
    using namespace std;
    cout << "Name: " << app->name << endl
         << "Cradit ratings: " << app->credit_ratings << endl;
}

// 13. Предположим, что функции f1 () и f2 () имеют следующие прототипы:
// void fl (applicant *а);
// const char *f2(const applicant*a1,const applicant*а2);
void f1(applicant *a);
const char *f2(const applicant *a1, const applicant *a2);
// Объявите p1 как указатель на функцию f1, а р2 - как указатель на f2. Объявите указатель на массив из десяти указателей того же типа, что и р2. Воспользуйтесь typedef.