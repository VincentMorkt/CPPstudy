
/*Выполните упражнение 6, но измените его так, чтобы данные можно было получать из файла. Первым элементом файла должно быть количество меценатов,
а остальная часть состоять· из пар строк, в которых первая строка содержит
имя, а вторая - сумму пожертвования. То есть файл должен выглядеть примерно так:
4
Sam Stone
2000
Freida Flass
100500
Tammy Tubbs
5000
Rich Raptor
55000*/

/*Постройте программу, которая отслеживает пожертвования в Общество Защиты Влиятельных Лиц. Она должна запрашивать у пользователя количество меценатов,
а затем приглашать вводить их имена и суммы пожертвований от каждого. Информация должна сохраняться в динамически выделяемом массиве структур.
Каждая структура должна иметь два члена: символьный массив (или объект string) для хранения имени и переменную-член типа double - для хранения суммы пожертвования.
После чтения всех данных программа должна отображать имена и суммы пожертвований тех, кто не пожалел $ 10 ООО и более. Этот список должен быть озаглавлен меткой
"Graпd Patroпs". После этого программа должна выдать список остальных жертвователей. Он должен быть озаглавлен "Patroпs".
Если в одной из двух категорий не окажется никого, программа должна напечатать "nоnе". Помимо отображения двух категорий, никакой другой сортировки делать не нужно.
*/

#include <iostream>
#include <fstream>
#include <ctime>
#include <string>

const int Num = 30;
struct patrons
{
    std::string name;
    double donation;
};

int main()
{
    using namespace std;

    // работа с данными ////////////////////////////////////////////////////

    ifstream inFile; // объявление переменной обїекта ifstream
    clock_t delay = 5 * CLOCKS_PER_SEC;
    clock_t start;
    char fileName[Num]; // создание символьного массива для ввода имени файла. метод .open требует строк в стиле С.
    cout << "Enter the file name in the format name.txt: ";
    cin.getline(fileName, Num);

    // открытие файла и проверка успешности открытия ////////////////////////

    inFile.open(fileName);   // открытие файла для работы с ним
    if (!(inFile.is_open())) // проверка открытия файла
    {
        cout << "OPEN FAILURE! Maybe try name.txt.txt\nClosing..."; // сообщение об ошибке
        start = clock();
        while (clock() - start < delay) // таймер задержки
            continue;
        exit(EXIT_FAILURE); // закрытие программы
    }

    // чтение файла ///////////////////////////////////////////////////////////////////////////////

    int numOfPatrons = 0;
    inFile >> numOfPatrons;
    char ch = 0;
    {
        if (inFile.good())
            while (inFile.get(ch) && ch != '\n')
                ;
        else
        {
            cout << "Invalid input, numbers of patreons not find! Please edit file\nClosing...";
            start = clock();
            while (clock() - start < delay)
                ;
            exit(EXIT_FAILURE);
        }
    }
    patrons *list = new patrons[numOfPatrons]; // объявление динамического массива структур, состоящего из количества элементов, введённого ранее
    for (int i = 0; i < numOfPatrons; i++)     // цикл для последовательно ввода значений переменных массива структур
    {
        getline(inFile, list[i].name);
        inFile >> list[i].donation;
        while (inFile.get(ch) && ch != '\n')
            ;
    }

    // отображение данных ///////////////////////////////////////////////////////////////////////////

    cout << "\t Grand Patrons\n";
    bool noneMark = 0;                     // объявление переменной метки наличия прошедших проверку значений
    for (int i = 0; i < numOfPatrons; i++) // цикл вывода для списка Grand Patrons
        if (list[i].donation >= 10000)     // если сумма пожертвования больше 10000
        {
            cout << list[i].name << " - " << int(list[i].donation) << endl; // вывести имя и сумму пожертвования
            noneMark += 1;                                                  // увеличить значение метки
        }
    if (0 == noneMark)    // если метка не была ни разу увеличена (и, соответственно, отсутствуют значения, выводимые в списке Grand Patrons)
        cout << "none\n"; // вывести "none"

    cout << "\n\t Patrons\n";
    noneMark = 0;                          // обнуление метки
    for (int i = 0; i < numOfPatrons; i++) // цикл вывода для списка Patrons
        if (list[i].donation < 10000)      // далее всё аналогично кроме условия проверки (< вместо >=)
        {
            cout << list[i].name << " - " << list[i].donation << endl;
            noneMark += 1;
        }
    if (0 == noneMark)
        cout << "none\n";

    // завершение программы ///////////////////////////////////////////////////////////////////////////

    delete[] list; // освобождение памяти, занимаемой динамическим массивом структур

    cout << "\nPress <ENTER> to close.";
    cin.get(); // ожидание ввода для просмотра результатов работы программы
    return 0;
}